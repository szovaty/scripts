#!/bin/bash
# vim:set ts=2 sw=2:
# Base template2.src version 1.0 last modified 2018.01.11 by y

y_start(){ :; }
y_exit(){ :; }
y_help(){ :; }

trap y_exit TERM HUP INT

# Source the function library
ylib () {
  FSH="y_bash_lib"
  LIB=`which $FSH`
  test $? != '0' && { echo Fatal Error!; exit 1; }
  test -r ${LIB} && source ${LIB}
}
ylib

# Uncomment this to allow colors on the console
USE_COLOR=$YES

# This will enable positioning of a text to the end (-8 char) 
# of a line independent of window size
USE_POS=$YES

# Enable bell for warnings and errors
#USE_BELL=$YES

# define the following to match the program current state
PROGRAM_NAME="ynew_dev2"
VERSION="0.0"
LAST_MOD="2018.01.25"

# Define log file here
LOG="/tmp/${0##*/}.log"

# Uncomment this if you need debug enabled
#Y_DEBUG=$TRUE

# use these to set cleanup on exit
#MOUNTED=""             # y_exit will unmount them
#DELETE_ON_EXIT=""      # y_exit will delete them
#LAST_CMD=""            # y_exit will run it just before exit

# Uncomment to make script quiet
#Y_QUIET=$FALSE

# Uncomment to ask for confirmation 
#Y_CONFIRM=$TRUE

# destination options: LOG,STDOUT,STDERR
Y_MSG_DEST="LOG"
ylib

# -------------- configuration defaults -----------------------
Y_MOUNT_DEV="$FALSE"
Y_DEV_DEV="/dev/sdb3"
Y_DEV_MNT="/xy"
Y_SRC_DIRS="/usr /var /opt /boot"
Y_SRC_FSTAB="/etc/fstab.dev"
Y_PART_GENTOO="/dev/sdb2"

#y_init_screen
y_start
# ===================================================================================
HELP="Defaults"
# read command line parameters
while [ -n "$1" ] ; do
  case $1 in
    --help|-h)	y_help "[Options]"; y_exit;;    #; Help [HELP]
    --quiet|-Q) Y_QUIET="true";;                #; Enable quiet mode [Y_QUIET]
    --debug|-D) Y_DEBUG="true";;                #; Enable debug mode [Y_DEBUG]
    --dry|-N)   Y_DRY_RUN="true";;              #; Execute dry run mode [Y_DRY_RUN]
    --nocolor)  USE_COLOR="";;                  #; Enable color output [USE_COLOR]
    --log|-L)   LOG="$2"; shift;;               #; Set log destination [LOG]
    --version|-V) y_version; y_exit;;           #; Display version and exit
    --dev|-d)   Y_DEV_DEV="$2"; shift;;         #; Set device [Y_DEV_DEV]
    --mnt|-M)   Y_DEV_MNT="$2"; shift;;         #; Set DEV root [Y_DEV_MNT]
    --mountdev) Y_MOUNT_DEV="true";;            #; Mount DEV FS [Y_MOUNT_DEV]
    --src_dirs) Y_SRC_DIRS="$2"; shift;;        #; Source dirs [Y_SRC_DIRS]
    --src_fstab) Y_SRC_FSTAB="$2";shift;;       #; fstab to as source [Y_SRC_FSTAB]
    --gentoo)   Y_PART_GENTOO="$2";shift;;      #; Define gentoo partition [Y_PART_GENTOO]
    --noclean)  Y_NOCLEAN="true";;              #; Do not clean on exit [Y_NOCLEAN]
    --sync)     Y_SYNC="true";;                 #; Sync gentoo files [Y_SYNC]
    --update)   Y_UPDATE="true";;               #; Update Gentoo [Y_UPDATE]
    --check)    Y_CHECK="true";;                #; Pre-check build [Y_CHECK]
    --build)    Y_BUILD="true";;                #; Build/update DEV system [Y_BUILD]
    --lkernel)  Y_LINK_KERNEL="true";;          #; Link kernel [Y_LINK_KERNEL]
    --ckernel)  Y_CONFIG_KERNEL="true";;        #; Config kernel [Y_CONFIG_KERNEL]
    --bkernel)  Y_BUILD_KERNEL="true";;         #; Build kernel [Y_BUILD_KERNEL]
    --lilo)     Y_LILO="true";;                 #; Update bootloader [Y_LILO]
    --rebuild)  Y_REBUILD="true";;              #; Rebuild system after new kernel
    --cgentoo)  Y_CGENTOO="true";;              #; Clean Gentoo [Y_CGENTOO]
    --qtest)    Y_QUICKTEST="true";;            #; Test new sys by chroot [Y_QUICKTEST]
    --systest)  Y_SYSTEST="true";;              #; Test by reboot into DEV [Y_SYSTEST]
#    *)          y_fatal_error "Unknown command";;
  esac
  shift
done

y_set_default Y_MSG_DEST "LOG"
y_set_default Y_DEBUG_ON_ERROR $FALSE
y_set_default Y_EXIT_ON_ERROR $FALSE
ylib

y_check_dryrun_not && test $(id -u) -ne 0 && 
  y_fatal_error "Script should run as root!"

# mount DEV ROOT_FS if it is not mounted yet
! y_check_mount "$Y_DEV_DEV" "$Y_DEV_MNT" && {
    y_progress_nl "Mount DEV root on $Y_DEV_MNT..."
    y_run "fsck -p "$Y_DEV_DEV" 2>&1 >> $LOG"
    y_run mkdir -p $Y_DEV_MNT
    y_mount "$Y_DEV_MNT"
    y_progress_end $?
}

# sync dev to current
test -n "$Y_SYNC" && {
    y_progress_nl "Sync DEV system with current install..."
    y_run yrsync_xos -x "$Y_DEV_MNT" -f /etc/fstab.dev -d \"$Y_SRC_DIRS\" -m
    y_run rm $Y_DEV_MNT/gentoo
    y_progress_end $?
}  

# mount system on DEV
test -n "$Y_MOUNT_DEV" && {
    y_progress_nl "Mount DEV system devices..."
    y_run mkdir -p $Y_DEV_MNT/dev
    y_mount --bind /dev $Y_DEV_MNT/dev
    y_run mkdir -p $Y_DEV_MNT/dev/pts
    y_mount --bind /dev/pts $Y_DEV_MNT/dev/pts
    y_run mkdir -p $Y_DEV_MNT/proc
    y_mount -t proc proc "$Y_DEV_MNT"/proc
    y_run mkdir -p $Y_DEV_MNT/gentoo
    test ! -d $Y_DEV_MNT/gentoo/portage &&
      y_mount $Y_PART_GENTOO ${Y_DEV_MNT}/gentoo
    PORTAGE_TMP=`y_run "emerge --info 2>/dev/null | grep PORTAGE_TMPDIR"`
    y_run mkdir -p $Y_DEV_MNT${PORTAGE_TMP##*PORTAGE_TMPDIR=}
    y_progress_end $?
}

# clean up gentoo files: packages and distfiles
test -n "$Y_CGENTOO" && {
    y_progress_nl "Clear Gentoo build files...."
    y_run eclean-pkg
    y_progress_end $?
}

# update build system on DEV: emerge --sync
test -n "$Y_UPDATE" && {
   y_progress_nl "Update gentoo build cache..."
    #y_run chroot $Y_DEV_MNT emerge --sync
    y_run chroot $Y_DEV_MNT emaint -a sync
    y_run chroot $Y_DEV_MNT emerge -1q portage
    y_progress_end $?
}

# check if it would build: emerge -pvuDN world
test -n "$Y_CHECK" && {
    y_progress_nl "Pre-Check build..."
    y_run chroot $Y_DEV_MNT emerge -pvuDN --verbose-conflicts world
    y_progress_end $Y_RUN_RET
}

# build system on DEV: emerge -qubDN world
test -n "$Y_BUILD" && {
    y_progress_nl "Build/update DEV system..."
    y_run chroot $Y_DEV_MNT emerge -quDN world
    y_run chroot $Y_DEV_MNT etc-update
    y_progress_end $y
}

#y_debug_console

# ===================================================================================
# Leave this as the last line
y_exit
