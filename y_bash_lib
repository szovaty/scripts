#!/bin/bash
# vim:set ts=2 sw=2:
# Bash generic function script by Y
# TODO: porting from y_functions.sh not finished yet! DO NOT USE
# TODO: dynamic help spacing
Y_BASH_LIB_VER="0.1"
Y_LASTMOD="2018.01.16"

# set below control variables before sourcing this file in your script!

# terminal color settings
unset NORM GOOD ERR BAD WARN ATTEN LINK BLINK BLINKOFF REV REVOFF DRYRUN
Y_FIXME="FIXME# "

if [ "$USE_COLOR" = "yes" ] ; then
  NORM=$'\e[0m'
  GOOD=$'\e[32m'
  ERR=$'\e[31;01m'
  BAD=$ERR
  WARN=$'\e[35;01m'
  DRYRUN=$'\e[94m'
  ATTEN=$'\e[94;01m'
  LINK=$'\e[34;01m'
  BLINK=$'\e[5m'
  BLINKOFF=$'\e[25m'
  REV=$'\e[7m'
  REVOFF=$'\e[27m'
  Y_FIXME="\[\033[01;31m\]${Y_FIXME}\[\033[00m\]"
fi

Y_FIXME_PS1="/tmp/yps1.$$"
echo PS1=\"$Y_FIXME\" > $Y_FIXME_PS1

# positioning
ENDCOL=""
if [ "$USE_POS" = "yes" ] ; then
  COLS="`stty size 2>/dev/null`"
  COLS=$((${COLS#*' '}-8))
  ENDCOL=$'\e[A\e['$COLS'G'
fi

# Globally used constances
YES="yes"
NO="no"
TRUE="true"
FALSE="false"
ERROR=1
NOERROR=0
Y_DATE="date +%Y.%m.%d-%T"

#Defaults
test -z "$LOG" && LOG="/dev/null"
test -z "$TMP_DIR" && TMP_DIR="/tmp"
test -z "$WORK_DIR" && WORK_DIR="/tmp"
test -z "$CMD_WHICH" && CMD_WHICH="which"
test -z "$STD_ERR" && STD_ERR="/dev/stderr"
test -z "$STD_OUT" && STD_OUT="/dev/stdout"

# Generic funtion definitions

# bells
y_bell () {	
	test "$USE_BELL" = "yes" &&	{ 
		echo -en "\\007"
		case $1 in
			ERROR)	sleep 0.3; echo -en "\\007";;
			FATAL) sleep 0.3; echo -en "\\007"; sleep 0.3; echo -en "\\007";;
		esac
	}
}


# init_screen function
y_init_screen () {
  test -n "$Y_QUIET" && return
  clear
  echo -e ${NORM}
  echo "======================================================================="
  echo -e "            ${GOOD}Welcome to $PROGRAM_NAME Ver. $VERSION"${NORM}
  echo -e "                     by ${LINK}http://www.DDr.hu"${NORM}
  echo "======================================================================="
  echo 
  echo
  echo "For help exit now and start the program with --help option."
  echo -e "      Like this:   ${GOOD}${0##*/} --help${NORM}"
  echo
  y_get_confirm "   Continue? ($YES):"
}

# self documenting program options from the source
# return opts as a string with comments
# add #; at the begin that you want to show up on the help screen
# comments needs to be inline with the comment option!
y_help_opt () {
  local HELPMSG MSG DEF i j k x
  IFS=$'\n'
  for i in `cat $0 | grep -e '#;'` ; do
    HELPMSG="${i##*'#;'}"
    #i=${i#*[' ',$'\t']}
    i=${i%)*} ; 
    if [ "${i##*'#;'}" = "${HELPMSG}" ] ; then 
      printf "%20s %s\n" ' ' $HELPMSG
      continue 
    fi
    IFS=$'|'
    for j in $i ; do
      if [ "${j%\$*}" = "$j" ] ; then k=$i ; break ; fi
      eval x='$'${j#*\$}
      if [ -z "$k" ] ; then k=$x ; else k="$k|$x" ; fi
	done
	k="${k}:"
	IFS=$' \t\n' ; MSG="" ; DEF=""
	for j in $HELPMSG ; do
    if [ "${j#*[}" != "$j" ] ; then 
        eval j='$'${j#*[} ; 
        DEF="[${j}" ; 
        continue ; 
    fi
    MSG="$MSG $j"
	done
	IFS=$'\n'
	k=`echo $k | awk ' { print $1 }'`
	printf "%20s %-40s %s\n" "${k}" "$MSG" "$DEF" 
	k=""
    done
    IFS=$' \t\n'
}

# generic message function
# usage: y_mesg type dest mess
#	type: fatal_error, error, warning, debug, info
#	dest: 0 - stdout/stderr ; 1 - log_file ; 2 - both
# 	mess: message to report
# return $ERROR | $NOERROR
Y_MSG_TYPE=""
y_error () 	      { Y_MSG_TYPE="ERROR"; y_msg "$*" ; }
y_fatal_error ()  { Y_MSG_TYPE="FATAL"; y_msg "$*" ; y_exit;}
y_warning () 	    { Y_MSG_TYPE="WARN";  y_msg "$*" ; }
y_debug ()	      { Y_MSG_TYPE="DEBUG"; y_msg "$*" ; }
y_dryrun ()	      { Y_MSG_TYPE="DRYRUN";y_msg "$*" ; }
y_info ()	        { Y_MSG_TYPE="INFO";  y_msg "$*" ; }
y_usage ()	      { Y_MSG_TYPE="USAGE"; y_msg "$*" ; }
y_help (){
  Y_MSG_TYPE="INFO"
  X=$Y_MSG_DEST
  Y_MSG_DEST="STDOUT"
  y_msg "$PROGRAM_NAME Version $VERSION; $LAST_MOD"
  Y_MSG_TYPE="HELP"
	y_msg "${0##*/} \\n\\n`y_help_opt ; echo $*`"
  Y_MSG_DEST=$X
}
y_msg () {
  test -w "$LOG" || {
    test -e "$LOG" || touch "$LOG" 2>/dev/null
    test -w "$LOG" || LOG=/dev/null
  }
  case $Y_MSG_TYPE in
    FATAL)	  MESG_COLOR=$ERR  ; BELL=FATAL;;
    ERROR)	  MESG_COLOR=$ERR  ; BELL=ERROR;;
    WARN)     MESG_COLOR=$WARN ; BELL=WARNING;;	
    DEBUG)	  MESG_COLOR=$NORM ;;
    DRYRUN)	  MESG_COLOR=$DRYRUN ;;
    INFO)	    MESG_COLOR=$NORM ;;
    USAGE)	  MESG_COLOR=$WARN ;;
    HELP)	    MESG_COLOR=$NORM ;;
    *)        return $ERROR
  esac
  test ! -w "$MSG_OUT" && MSG_OUT=/dev/null
  test -n "$Y_QUIET" -a $Y_MSG_TYPE != "HELP" && MSG_OUT=/dev/null

  MSG_HEADER_LOG=`printf "%020s(%05d) %08s" ${0##*/} $$ $Y_MSG_TYPE`
  MSG_HEADER_STD=`printf "%08s"$Y_MSG_TYPE`

  echo "$Y_MSG_DEST" | grep STDOUT > /dev/null
  test $?  -eq 0 &&
    echo -e "  ${MESG_COLOR}$MSG_HEADER_STD: $*${NORM}" >> $STD_OUT
  echo "$Y_MSG_DEST" | grep STDERR > /dev/null
  test $? -eq 0 &&
    echo -e "  ${MESG_COLOR}$MSG_HEADER_STD: $*${NORM}" >> $STD_ERR
  echo "$Y_MSG_DEST" | grep LOG > /dev/null
  test $? -eq 0 && 
    echo -e "  `$Y_DATE` $MSG_HEADER_LOG: $*" >> $LOG

  test -n "$BELL" && y_bell $BELL
}

# clean up and exit
# set LAST_CMD, MOUNTED and DELETE_ON_EXIT lists
y_exit () {
	local i EXIT_STAT=0
	test -n "$1" && EXIT_STAT=$1
	if [ -n "$MOUNTED" ] ; then
		for i in $MOUNTED ; do
			`umount -l $i > /dev/null`
			test "$?" = "1" && y_error 2 "umount $i"
		done
	fi
    MOUNTED=""
	for i in "$DELETE_ON_EXIT" ; do
		`rm -f -r $i > /dev/null`
		test "$?" -ne 0 && y_error 2 "delete $i"
	done
  X=$Y_MSG_DEST
  Y_MSG_DEST="LOG"
	y_info "  End: $0"
  Y_MSG_DEST=$X
	test -n "$LAST_CMD" && { $LAST_CMD ; EXIT_STAT=$? ; }
	IFS=$' \t\n'
	exit $EXIT_STAT
}

y_start () { 
  X=$Y_MSG_DEST
  Y_MSG_DEST="LOG"
  y_info "Start: $0 $1 ; [V${VERSION} , Last modified: ${LAST_MOD}]"
  Y_MSG_DEST=$X
}

# print version information
y_version () { echo "Version: V$VERSION ; Last Mod. $LAST_MOD" ; }

# ask user if OK to continue
y_get_confirm () {
  local X
  test -z "$Y_CONFIRM" && return
  echo -n $*" "
  read X
  LAST_CMD="y_debug Exiting"
  test "$X" != "$YES" && y_exit
}

# report progress
y_progress () { 
  test -z "$Y_QUIET" && 
    printf "%s%010s%s: %s\n" "${GOOD}" "PROGRESS" "${NORM}" "$1" >>/dev/stderr
}

y_progress_1 () { 
  printf "%s%010s%s: %s" "${GOOD}" "PROGRESS" "${NORM}" "$1" >>/dev/stderr
}

y_progress_end () { 
	test -z "$Y_QUIET" || return
  case $1 in
    0)	echo -e "${ENDCOL}${LINK}[ ${GOOD}OK ${LINK}]${NORM}" >>/dev/stderr ;;
    1)	echo -e "${ENDCOL}${LINK}[ ${ERR}!! ${LINK}]${NORM}" >>/dev/stderr ;; 
    2)	echo -e "${ENDCOL}${LINK}[ ${WARN}-- ${LINK}]${NORM}" >>/dev/stderr ;; 
    *)	echo -e "${ENDCOL}${LINK}[ ${WARN}?? ${LINK}]${NORM}" >>/dev/stderr ;; 
  esac
}

# report disk size in MBytes
# usage: y_get_disksize disk
# return: disk size in MBytes
y_get_disksize () {
  local x
  x=`fdisk -l $1 2>/dev/null | grep ${1}: | awk ' { print $5 }'` 
  y_debug 1 "DISK_SIZE=[$x]"
  # x=${x%' '*} ; x=${x##*' '} ; 
  x=$(($x/1024/1024))
  echo $x
}

# get_dir_size: get dir size of a list of dirs
#  usage: get_dir_size list_of_dirs
#  return: set sum dir size in DIR_SIZE
# local variables: *_4
y_get_dirsize () { 
  local x
  x=`du -s -c -m $1 | grep total`
  x=`echo $x`
  x=${x%%total}
  return $x
}

# get dir size minus the exclude dirs in the second parameter (a file with the list like tar exclude)
#  usage: getdirsize_excl dir_name filename_with_exclude_list_in extra_option_for_du
#  return: set dir size in DIR_SIZE variable
y_get_dirsize_excl () {
  local i ; local j ; local x ; local FROM
  
  FROM=$1
  j=""
  for i in `ls -A $1 2>/dev/null | grep --file=$2 -v 2>/dev/null` ; do
    j="$j ${FROM%/}/$i"
  done 
  x=`$RCMD du -s $3 -c $j_5 2>/dev/null | grep total 2>/dev/null`
  x=`echo $x`
  return ${x%%total}
}

# get free space on device
y_get_free_space () {
  local x
  x=`df $1 | grep /` ; x=`echo ${x#*' '}` ; x=`echo ${x#*' '}` ; x=`echo ${x#*' '}`
  x=`echo ${x%%$Y*}`; return $x
}

# check if commands are available
# usage: y_check_cmds command_list
y_check_cmds () {
  local i CMD
  for i in $1 ; do
    CMD=`which $i 2>&1`
    test "$?" = "1" && { y_error 2 "Command $i not found!" ; return $ERROR ; }
    test -x "$CMD" || { y_error 2 "Can not run $CMD command" ; return $ERROR ; }
  done
}

# check if a program return with no error
y_check_exec () {
  test $? -eq 0 && return
  shift
  y_debug 2 "FAILED: $*"
  test "$Y_EXIT_ON_ERROR" = $TRUE && 
    y_exit
  test "$Y_DEBUG_ON_ERROR" = $TRUE && {
    y_run_debug_help
    bash --rcfile $Y_FIXME_PS1 -i
  }
}

# run debug console help screen
y_run_debug_help () {
  echo "----------------------------------------"
  echo "Debug console exit options:"
  echo "  exit  : skip failed command"
  echo "  exit 1: retry failed command"
  echo "  exit 2: terminate execution"
  echo "-----------------------------------------"
}

# run command with dry_run, debug and debug console feature
y_run () {
  test -z "$1" && return
  RET=1
  while [ $RET -ne 0 ]; do
    if [ "$Y_DRY_RUN" = "$TRUE" ]; then
      y_dryrun 1 "$*"
      return 0
    else
      y_debug 1 "$*"
    fi     

    if [ "$Y_QUIET" != $TRUE ] ; then
      if [ "$Y_DEBUG" = "TRUE" ] ; then
        eval $* | tee -a $LOG
      else
        eval $*
      fi
    else
      eval $* 2>&1 >> $LOG
    fi
    y_check_exec $? $*
    RET=$?
    test $RET -eq 2 && exit 2
  done
}

# FIXME
y_set_default () { 
  local X
  eval X='$'$1
  test -z "$X" && eval $1=\"$2\"
}

# Mark log with a string
y_mark_log () {	
  for i in {0..80..1} ; do echo -n "=" >> $LOG; done
  echo >> $LOG
}

