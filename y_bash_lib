#!/bin/bash
# vim:set ts=2 sw=2:
# Bash generic function script by Y
#  it is a refactored version of y_functions.sh
#
# TODO: port a few old script and test the new lib

Y_BASH_LIB_VER="1.0-rc2"
Y_LASTMOD="2018.01.18"

# set below control variables before sourcing this file in your script!

# terminal color settings
unset NORM GOOD ERR BAD WARN ATTEN LINK BLINK BLINKOFF REV REVOFF DRYRUN
Y_FIXME="FIXME# "

if [ "$USE_COLOR" = "yes" ] ; then
  NORM=$'\e[0m'
  GOOD=$'\e[32m'
  ERR=$'\e[31;01m'
  BAD=$ERR
  WARN=$'\e[35;01m'
  DRYRUN=$'\e[94m'
  ATTEN=$'\e[94;01m'
  LINK=$'\e[34;01m'
  BLINK=$'\e[5m'
  BLINKOFF=$'\e[25m'
  REV=$'\e[7m'
  REVOFF=$'\e[27m'
  Y_FIXME="\[\033[01;31m\]${Y_FIXME}\[\033[00m\]"
fi

Y_FIXME_PS1="/tmp/yps1.$$"
echo PS1=\"$Y_FIXME\" > $Y_FIXME_PS1

# Globally used constances
YES="yes"
NO="no"
TRUE="true"
FALSE="false"
ERROR=1
NOERROR=0
Y_DATE="date +%Y.%m.%d-%T"

#Defaults
test -z "$LOG" && LOG="/dev/null"
test -z "$TMP_DIR" && TMP_DIR="/tmp"
test -z "$WORK_DIR" && WORK_DIR="/tmp"
test -z "$CMD_WHICH" && CMD_WHICH="which"
test -z "$STD_ERR" && STD_ERR="/dev/stderr"
test -z "$STD_OUT" && STD_OUT="/dev/stdout"

# positioning
if [ "$USE_POS" = $YES ] ; then
  COLS="`stty size 2>/dev/null`"
  COLS=$((${COLS#*' '}-8))
  ENDCOL=$'\033[A\033['$COLS'G'
  #echo -e ENDCOL=[$ENDCOL]
fi

# Generic funtion definitions

# bells
y_bell () {	
	test "$USE_BELL" = "yes" &&	{ 
		echo -en "\\007"
		case $1 in
			ERROR)	sleep 0.3; echo -en "\\007";;
			FATAL) sleep 0.3; echo -en "\\007"; sleep 0.3; echo -en "\\007";;
		esac
	}
}

# init_screen function
y_init_screen () {
  test "$Y_QUIET" = $TRUE && return
  clear
  echo -e ${NORM}
  echo "======================================================================="
  echo -e "            ${GOOD}Welcome to $PROGRAM_NAME Ver. $VERSION"${NORM}
  echo -e "                     by ${LINK}http://www.DDr.hu"${NORM}
  echo "======================================================================="
  echo 
  echo
  echo "For help exit now and start the program with --help option."
  echo -e "      Like this:   ${GOOD}${0##*/} --help${NORM}"
  echo
  y_get_confirm "   Continue? ($YES):"
}

# self documenting program options from the source
# return opts as a string with comments
# add #; at the begin that you want to show up on the help screen
# comments needs to be inline with the comment option!
y_help_opt () {
  #local HELPMSG MSG DEF i j k x
  LINE=0
  IFS=$'\n'
  for i in `cat $0 | grep -e '#;'` ; do
    HELPMSG="${i##*'#;'}"
    #i=${i#*[' ',$'\t']}
    i=${i%)*} ; 
    if [ "${i##*'#;'}" = "${HELPMSG}" ] ; then 
      printf "%20s %s\n" ' ' $HELPMSG
      continue 
    fi
    IFS=$'|'
    for j in $i ; do
      if [ "${j%\$*}" = "$j" ] ; then 
        k=$i
        break
      fi
      eval x='$'${j#*\$}
      if [ -z "$k" ] ; then 
        k=$x
      else 
        k="$k|$x"
      fi
	  done
	  k="${k}:"
	  IFS=$' \t\n'
    MSG=""
    DEF=""
    for j in $HELPMSG ; do
      if [ "${j#*[}" != "$j" ] ; then 
        eval j='$'${j#*[}
        DEF="[${j}"
        continue
      fi
      MSG="$MSG $j"
    done
    IFS=$'\n'
    k=`echo $k | awk ' { print $1 }'`
    HELP_OPT[$LINE]="$k"
    HELP_MSG[$LINE]="$MSG"
    HELP_DEF[$LINE]="$DEF"
    LINE=$(($LINE+1))
    #printf "%20s %-40s %s\n" "${k}" "$MSG" "$DEF" 
    k=""
  done
  IFS=$' \t\n'
  HELP_OPT_MAX=0
  HELP_MSG_MAX=0
  for (( i=0; i<$LINE; i++)) ; do
    HELP_OPT_CUR=`echo ${HELP_OPT[$i]} | awk '{print length}'`
    test $HELP_OPT_CUR -gt $HELP_OPT_MAX && HELP_OPT_MAX=$HELP_OPT_CUR
    HELP_MSG_CUR=`echo ${HELP_MSG[$i]} | awk '{print length}'`
    test $HELP_MSG_CUR -gt $HELP_MSG_MAX && HELP_MSG_MAX=$HELP_MSG_CUR
  done
  HELP_OPT_MAX=$((HELP_OPT_MAX+4))
  HELP_MSG_MAX=$((HELP_MSG_MAX+2))
  for (( i=0; i<$LINE; i++)) ; do
    printf "%${HELP_OPT_MAX}s %-${HELP_MSG_MAX}s %s\n" \
      "${HELP_OPT[$i]}" "${HELP_MSG[$i]}" "${HELP_DEF[$i]}"
  done
}

# generic message function
# usage: y_mesg type dest mess
#	type: fatal_error, error, warning, debug, info
#	dest: 0 - stdout/stderr ; 1 - log_file ; 2 - both
# 	mess: message to report
# return $ERROR | $NOERROR
Y_MSG_TYPE=""
y_error () 	      { Y_MSG_TYPE="ERROR"; y_msg "$*" ; }
y_fatal_error ()  { Y_MSG_TYPE="FATAL"; y_msg "$*" ; y_exit;}
y_warning () 	    { Y_MSG_TYPE="WARN";  y_msg "$*" ; }
y_debug ()	      { Y_MSG_TYPE="DEBUG"; y_msg "$*" ; }
y_dryrun ()	      { Y_MSG_TYPE="DRYRUN";y_msg "$*" ; }
y_info ()	        { Y_MSG_TYPE="INFO";  y_msg "$*" ; }
y_usage ()	      { Y_MSG_TYPE="USAGE"; y_msg "$*" ; }
y_help (){
  Y_MSG_TYPE="HELP"
  X=$Y_MSG_DEST
  Y_MSG_DEST="STDOUT"
  y_msg "${0##*/} V$VERSION; $LAST_MOD \\n`echo $*; y_help_opt`"
  Y_MSG_DEST=$X
}
y_msg () {
  test -w "$LOG" || {
    test -e "$LOG" || touch "$LOG" 2>/dev/null
    test -w "$LOG" || LOG=/dev/null
  }
  case $Y_MSG_TYPE in
    FATAL)	  MESG_COLOR=$ERR  ; BELL=FATAL;;
    ERROR)	  MESG_COLOR=$ERR  ; BELL=ERROR;;
    WARN)     MESG_COLOR=$WARN ; BELL=WARNING;;	
    DEBUG)	  MESG_COLOR=$NORM ;;
    DRYRUN)	  MESG_COLOR=$DRYRUN ;;
    INFO)	    MESG_COLOR=$NORM ;;
    USAGE)	  MESG_COLOR=$WARN ;;
    HELP)	    MESG_COLOR=$NORM ;;
    *)        return $ERROR
  esac
  test ! -w "$MSG_OUT" && MSG_OUT=/dev/null
  
  STDPUT=$STD_OUT
  if [ "$Y_QUIET" = $TRUE -a $Y_MSG_TYPE != "HELP" ]; then
    STDOUT=/dev/null
  else
    STDOUT=$STD_OUT
  fi

  MSG_HEADER_LOG=`printf "%020s(%05d) %08s" ${0##*/} $$ $Y_MSG_TYPE`
  MSG_HEADER_STD=`printf "%08s"$Y_MSG_TYPE`

  echo "$Y_MSG_DEST" | grep STDOUT > /dev/null
  test $?  -eq 0 &&
    echo -e "  ${MESG_COLOR}$MSG_HEADER_STD: $*${NORM}" >> $STDOUT
  echo "$Y_MSG_DEST" | grep STDERR > /dev/null
  test $? -eq 0 &&
    echo -e "  ${MESG_COLOR}$MSG_HEADER_STD: $*${NORM}" >> $STD_ERR
  echo "$Y_MSG_DEST" | grep LOG > /dev/null
  test $? -eq 0 && 
    echo -e "  `$Y_DATE` $MSG_HEADER_LOG: $*" >> $LOG

  test -n "$BELL" && y_bell $BELL
}

# clean up and exit
# set LAST_CMD, MOUNTED and DELETE_ON_EXIT lists
y_exit () {
	local i EXIT_STAT=0
	test -n "$1" && EXIT_STAT=$1
	if [ -n "$MOUNTED" ] ; then
		for i in $MOUNTED ; do
			`umount -l $i > /dev/null`
			test "$?" = "1" && y_error 2 "umount $i"
		done
	fi
    MOUNTED=""
	for i in "$DELETE_ON_EXIT" ; do
		`rm -f -r $i > /dev/null`
		test "$?" -ne 0 && y_error 2 "delete $i"
	done
  X=$Y_MSG_DEST
  Y_MSG_DEST="LOG"
	y_info "  End: $0"
  Y_MSG_DEST=$X
	test -n "$LAST_CMD" && { $LAST_CMD ; EXIT_STAT=$? ; }
	IFS=$' \t\n'
	exit $EXIT_STAT
}

y_start () { 
  X=$Y_MSG_DEST
  Y_MSG_DEST="LOG"
  y_info "Start: $0 $1 ; [V${VERSION} , Last modified: ${LAST_MOD}]"
  Y_MSG_DEST=$X
}

# print version information
y_version () { echo "Version: V$VERSION ; Last Mod. $LAST_MOD" ; }

# ask user if OK to continue
y_get_confirm () {
  local X
  test -z "$Y_CONFIRM" && return
  echo -n $*" "
  read X
  LAST_CMD="y_debug Exiting"
  test "$X" != "$YES" && y_exit
}

# report progress with new line at the end
y_progress_nl () { 
  test "$Y_QUIET" != $TRUE && 
    printf "%s%010s%s: %s\n" "${GOOD}" "PROGRESS" "${NORM}" "$*" >>$STD_ERR
}

# report progress without new line at the end
y_progress () {
  test "$Y_QUIET" != $TRUE &&
    printf "%s%010s%s: %s" "${GOOD}" "PROGRESS" "${NORM}" "$*" >>$STD_ERR
}

y_progress_end () { 
  test "$Y_QUIET" = $TRUE && return
  case $1 in
    0)	echo -e "${ENDCOL}${LINK}[ ${GOOD}OK ${LINK}]${NORM}" >>$STD_ERR;;
    1)	echo -e "${ENDCOL}${LINK}[ ${ERR}!! ${LINK}]${NORM}" >>$STD_ERR ;; 
    2)	echo -e "${ENDCOL}${LINK}[ ${WARN}-- ${LINK}]${NORM}" >>$STD_ERR ;; 
    *)	echo -e "${ENDCOL}${LINK}[ ${WARN}?? ${LINK}]${NORM}" >>$STD_ERR ;; 
  esac
}

# report disk size in MBytes
# usage: y_get_disksize disk
# return: disk size in MBytes
y_get_disksize () {
  local x
  x=`fdisk -l $1 2>/dev/null | grep ${1}: | awk ' { print $5 }'` 
  y_debug "DISK_SIZE=[$x]"
  # x=${x%' '*} ; x=${x##*' '} ; 
  x=$(($x/1024/1024))
  echo $x
}

# get_dir_size: get dir size of a list of dirs
#  usage: get_dir_size list_of_dirs
#  return: set sum dir size in DIR_SIZE
# local variables: *_4
y_get_dirsize () { 
  local x
  x=`du -s -c -m $1 | grep total`
  x=`echo $x`
  x=${x%%total}
  return $x
}

# get dir size minus the exclude dirs in the second parameter (a file with the list like tar exclude)
#  usage: getdirsize_excl dir_name filename_with_exclude_list_in extra_option_for_du
#  return: set dir size in DIR_SIZE variable
y_get_dirsize_excl () {
  local i ; local j ; local x ; local FROM
  
  FROM=$1
  j=""
  for i in `ls -A $1 2>/dev/null | grep --file=$2 -v 2>/dev/null` ; do
    j="$j ${FROM%/}/$i"
  done 
  x=`$RCMD du -s $3 -c $j_5 2>/dev/null | grep total 2>/dev/null`
  x=`echo $x`
  return ${x%%total}
}

# get free space on device
y_get_free_space () {
  local x
  x=`df $1 | grep /` ; x=`echo ${x#*' '}` ; x=`echo ${x#*' '}` ; x=`echo ${x#*' '}`
  x=`echo ${x%%$Y*}`; return $x
}

# check if commands are available
# usage: y_check_cmds command_list
y_check_cmds () {
  local i CMD
  for i in $1 ; do
    CMD=`which $i 2>&1`
    test "$?" = "1" && { y_error 2 "Command $i not found!" ; return $ERROR ; }
    test -x "$CMD" || { y_error 2 "Can not run $CMD command" ; return $ERROR ; }
  done
}

# check if a program return with no error
y_check_exec () {
  test $1 -eq 0 && return 0
  shift
  y_error "$*"
  test "$Y_EXIT_ON_ERROR" = "$TRUE" && {
    y_exit
  }
  test "$Y_DEBUG_ON_ERROR" = $TRUE && {
    y_run_debug_help
    bash --rcfile $Y_FIXME_PS1 -i
  }
}

# run debug console help screen
y_run_debug_help () {
  echo "----------------------------------------"
  echo "Debug console exit options:"
  echo "  exit 0: skip failed command"
  echo "  exit 1: retry failed command"
  echo "  exit 2: terminate execution"
  echo "-----------------------------------------"
}

# run command with dry_run, debug and debug console feature
# usage: y_run command_to_run
# chroot usage: y_run chroot NEW_ROOT /bin/bash -c '"command to run"'
# you need to control it using:
#   Y_DRY_RUN - dry run
#   Y_DEBUG - show the command it executes
#   Y_QUIET - less message 
#   Y_DEBUG_ON_ERROR - enter debug console on error
#   Y_EXIT_ON_ERROR - exit if function fails
y_run () {
  test -z "$1" && return 1
  RET=1
  while [ $RET -ne 0 ]; do
    if [ "$Y_DRY_RUN" = $TRUE ]; then
      y_dryrun "$*"
      return 0
    else
      test "$Y_DEBUG" = $TRUE && y_debug "$*"
    fi     

    if [ "$Y_QUIET" = $TRUE ] ; then
      eval $* 2>&1 >> $LOG
    else
      if [ "$Y_DEBUG" = $TRUE ] ; then
        set -o pipefail
        eval $* | tee -a $LOG
        #RET=${PIPESTATUS[0]} # alternative to 'set -o pipefail'
      else
        eval $*
      fi
    fi
    y_check_exec $? $*
    RET=$?
    test $RET -eq 2 && exit 2
    test "$Y_DEBUG_ON_ERROR" != $TRUE && return $RET
  done
}

# Set a variable to default if it not set
# usage: y_set_default FOO FOO_DEFAULT
#   it sets variable FOO to FOO_DEFAULT if FOO not set yet
y_set_default () { 
  local X
  eval X='$'$1
  test -z "$X" && eval $1='"$2"'
}

# Mark log file with a string
y_mark_log () {
  C="="
  test -n "$1" && C=$1
  echo -n "#"  >> $LOG
  for i in {0..80..1} ; do 
    echo -n "$C" >> $LOG
  done
  echo "#">> $LOG
}

