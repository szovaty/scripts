#/bin/bash
# script creates an encrypted root partioned mint installation semi-automatically
#  Limitations: 
#   user needs to set partitions mounting points and fs type
#   user needs to select usual items for the install (like language,...)
#
Y_VER="0.95"
MODE_NEWSYS="new_system"
MODE_MIG="migrate"

# configuration
Y_MODE=$MODE_NEWSYS
Y_DEV="/dev/sda"

Y_BOOT_SIZE="400"
Y_SWAP_SIZE="8200"

Y_ROOT_NAME="root"
Y_ROOT_PASSWD="csolnok"

Y_ORIG_ROOT="/dev/mapper/root"
Y_ORIG_MOUNT="/boot"
Y_ORIG_MNT="/mnt"
Y_BKP_SRV="bp-nas"
Y_BKP_USER="jenov"
Y_BKP_PATH="/volume1/backup/tmp"

# input 
while [ -n "$1" ]; do
    case $1 in
        --help|-h)  echo "Usage: $0 [-d] [-n] [-l] [-h]"; exit 0;;
        --migrate|-m)  Y_MODE="$MODE_MIG";;
        --o_root)   test -n "$2" && Y_ORIG_ROOT="$2"; shift;;
        --b_user)   test -n "$2" && Y_BKP_USER="$2"; shift;;
        --debug|-d) Y_DEBUG="true";;
        --dry|-n)   Y_DRY_RUN="true";;
        --log|-l)   test -n "$2" && Y_LOG="$2"; shift;;
    esac
    shift
done

test "${Y_LOG}x" = "x" && export Y_LOG="$0.log"

echo VER=$Y_VER, DEBUG=$Y_DEBUG, LOG=$Y_LOG, DRY_RUN=$Y_DRY_RUN | tee -a $Y_LOG

# run function that checks sucessful command exit status and breaks if not
yrun () {
    if [ "$Y_DEBUG" = "true" ] ; then {
        echo DEBUG: "$*" | tee -a $Y_LOG
        OUT=${Y_LOG}
    }
    else
        OUT="/dev/null"
    fi
    test -z "$Y_DRY_RUN" && {
        test -n "$FOUT" && OUT=$FOUT
        if [ -n "$NOREDIR" ]; then
            $* 2>>$Y_LOG
        else
            $* >>$OUT 2>>$Y_LOG
        fi
        test "$?" = "0" || { echo "FATAL ERROR" | tee -a $Y_LOG; exit 1; }
    }
    return 0
}


# backup system before migration
test "$Y_MODE" = "$MODE_MIG" && {
    yrun sudo mount $Y_ORIG_ROOT $Y_ORIG_MNT
    yrun sudo mount --bind /dev $Y_ORIG_MNT/dev
    for i in $Y_ORIG_MOUNT; do
        yrun sudo chroot $Y_ORIG_MNT mount $i
    done

    yrun sudo umount $Y_ORIG_MNT/dev

    NOREDIR="true"
    yrun "tar -c $Y_ORIG_MNT | ssh $Y_BKP_USER@$Y_BKP_SRV Y_BKP_PATH=$Y_BKP_PATH 'cat > ${Y_BKP_PATH}/test.tar'"
    NOREDIR=""
}
exit 1
# setup partitions
#Y_LABEL="gpt"
Y_LABEL="msdos"

yrun sudo parted --script $Y_DEV mklabel $Y_LABEL

# Make sure Y_START>0 to leave space for the boot code
Y_START=1; Y_END=$Y_BOOT_SIZE
yrun sudo parted --script $Y_DEV mkpart primary ext2 $Y_START $Y_END

Y_START=$Y_END; Y_END=$(($Y_START+$Y_SWAP_SIZE))
yrun sudo parted --script $Y_DEV mkpart primary linux-swap $Y_START $Y_END

Y_START=$Y_END; Y_END="100%"
yrun sudo parted --script $Y_DEV mkpart primary ext2  $Y_START $Y_END

Y_BOOT="1"
Y_SWAP="2"
Y_ROOT="3"

yrun sudo parted --script $Y_DEV set $Y_BOOT "boot" on 

# setup filesystems
yrun sudo mkfs.ext2 -F ${Y_DEV}$Y_BOOT
yrun sudo mkswap -f ${Y_DEV}$Y_SWAP
echo $Y_ROOT_PASSWD | yrun sudo cryptsetup --cipher=aes-xts-plain --key-size=256 luksFormat ${Y_DEV}$Y_ROOT
echo $Y_ROOT_PASSWD | yrun sudo cryptsetup luksOpen ${Y_DEV}$Y_ROOT $Y_ROOT_NAME
yrun sudo cryptsetup -v status $Y_ROOT_NAME
yrun sudo mkfs.ext4 -F /dev/mapper/$Y_ROOT_NAME

test "$Y_MODE" = "$MODE_NEWSYS" && {
    # run GUI based installation
    echo "NOTE: Select 'Continue Testing' after installation finished!"
    yrun ubiquity -d
}

# fix up installed image
yrun sudo mount /dev/mapper/$Y_ROOT_NAME /mnt
yrun cd /mnt
yrun sudo mount ${Y_DEV}$Y_BOOT boot

test "$Y_MODE" = "$MODE_MIG" && {
    # restore system from backup
    yrun "ssh $Y_BKP_USER@Y_BKP_SRV 'cat $Y_BKP_PATH/test.tar | tar -x -C /'" 
}

yrun sudo mount --bind /dev dev
yrun sudo mount --bind /sys sys
yrun sudo mount -t proc proc proc

TMP="/tmp/ydev"
FOUT=$TMP
yrun blkid -o export ${Y_DEV}$Y_ROOT
FOUT=""

test -e $TMP || sleep 1
yrun source $TMP

FOUT=$TMP
yrun echo root UUID=$UUID none luks
FOUT=""

yrun sudo cp $TMP /mnt/etc/crypttab

yrun sudo chroot /mnt update-initramfs -u -k all

echo All should be DONE, reboot: `date`
#sudo init 0
